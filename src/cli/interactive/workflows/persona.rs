//! # Persona Workflow
//!
//! Interactive persona management for creating and managing personas.
//! Provides guided workflows for persona operations.

use anyhow::Result;
use inquire::{Select, Text};
use std::collections::HashMap;

use crate::cli::interactive::{field_helpers::FieldHelpers, runner::InteractiveRunner, ui::UI};

/// Persona workflow handler
pub struct PersonaWorkflow;

impl PersonaWorkflow {
    /// Interactive persona creation workflow
    ///
    /// Creates a minimal actor with auto-generated ID from name.
    /// The ID is automatically generated by slugifying the name (e.g., "End User" â†’ "end-user").
    /// Users can choose the actor type (Persona, System, Database, etc.).
    pub fn create_persona() -> Result<()> {
        use crate::core::utils::slugify_for_id;

        UI::show_section_header("Create Actor", "ðŸ‘¤")?;

        // Select actor type first
        let actor_type_options = vec![
            "Persona (Human user)",
            "System (Application component)",
            "Database",
            "External Service",
            "Custom",
        ];

        let actor_type_choice = Select::new("Actor type:", actor_type_options)
            .with_help_message("Choose the type of actor you're creating")
            .prompt()?;

        let actor_type = match actor_type_choice {
            "Persona (Human user)" => "Persona",
            "System (Application component)" => "System",
            "Database" => "Database",
            "External Service" => "ExternalService",
            "Custom" => "Custom",
            _ => "Persona",
        };

        let name = Text::new("Actor name:")
            .with_help_message("Display name (e.g., 'John Doe', 'Payment API', 'Database')")
            .prompt()?;

        let function = Text::new("Function/Role:")
            .with_help_message(
                "Role or function (e.g., 'System Administrator', 'Authentication Service', 'PostgreSQL')",
            )
            .prompt()?;

        // Auto-generate ID from name
        let id = slugify_for_id(&name);

        // Show the generated ID to the user
        println!("  Generated ID: {}", id);

        // Create the actor based on type
        let mut runner = InteractiveRunner::new();
        let result = if actor_type == "Persona" {
            runner.create_persona_interactive(id.clone(), name, function)?
        } else {
            // For system actors, ask for emoji (optional)
            let default_emoji = match actor_type {
                "Database" => "ðŸ’¾",
                "System" => "ðŸ–¥ï¸",
                "ExternalService" => "ðŸŒ",
                _ => "âš™ï¸",
            };

            let emoji = Text::new("Emoji (optional):")
                .with_default(default_emoji)
                .with_help_message("Visual identifier for this actor")
                .prompt()?;

            runner.create_system_actor_interactive(
                id.clone(),
                name,
                actor_type.to_string(),
                Some(emoji),
            )?
        };

        UI::show_success(&result)?;

        // Ask if user wants to add custom fields
        let add_fields = Select::new(
            "Would you like to add custom fields now?",
            vec!["No", "Yes"],
        )
        .with_help_message("You can always add/edit fields later")
        .prompt()?;

        if add_fields == "Yes" {
            let persona = runner.get_persona_details(&id)?;
            Self::edit_persona_fields(&mut runner, &id, &persona)?;
            // edit_persona_fields already has a pause, so we're done
        } else {
            UI::pause_for_input()?;
        }

        Ok(())
    }

    /// List all actors
    pub fn list_personas() -> Result<()> {
        UI::show_section_header("Actors", "ðŸ‘¥")?;

        let runner = InteractiveRunner::new();
        runner.list_personas()?;

        UI::pause_for_input()?;
        Ok(())
    }

    /// Show actor details
    pub fn show_persona() -> Result<()> {
        UI::show_section_header("Show Actor", "ðŸ”")?;

        let mut runner = InteractiveRunner::new();

        // Get list of actors
        let persona_ids = runner.get_persona_ids()?;

        if persona_ids.is_empty() {
            UI::show_error("No actors found.")?;
            UI::pause_for_input()?;
            return Ok(());
        }

        // Let user select which actor to view
        let selected_id = Select::new("Select actor to view:", persona_ids)
            .with_help_message("Choose the actor you want to see details for")
            .prompt()?;

        runner.show_persona(selected_id)?;

        UI::pause_for_input()?;
        Ok(())
    }

    /// Delete an actor
    pub fn delete_persona() -> Result<()> {
        UI::show_section_header("Delete Actor", "ðŸ—‘ï¸")?;

        let mut runner = InteractiveRunner::new();

        // Get list of actors
        let persona_ids = runner.get_persona_ids()?;

        if persona_ids.is_empty() {
            UI::show_error("No actors found.")?;
            UI::pause_for_input()?;
            return Ok(());
        }

        // Let user select which actor to delete
        let selected_id = Select::new("Select actor to delete:", persona_ids)
            .with_help_message("Choose the actor you want to delete")
            .prompt()?;

        // Confirm deletion
        let confirm = Select::new(
            &format!("Are you sure you want to delete actor '{}'?", selected_id),
            vec!["No", "Yes"],
        )
        .prompt()?;

        if confirm == "Yes" {
            runner.delete_persona(&selected_id)?;
            UI::show_success("Actor deleted successfully")?;
        } else {
            println!("\nâœ“ Deletion cancelled.");
        }

        UI::pause_for_input()?;
        Ok(())
    }

    /// Edit an existing actor
    pub fn edit_persona() -> Result<()> {
        UI::show_section_header("Edit Actor", "âœï¸")?;

        let mut runner = InteractiveRunner::new();

        // Get list of actors
        let persona_ids = runner.get_persona_ids()?;

        if persona_ids.is_empty() {
            UI::show_error("No actors found. Please create an actor first.")?;
            UI::pause_for_input()?;
            return Ok(());
        }

        // Let user select which actor to edit
        let selected_id = Select::new("Select actor to edit:", persona_ids)
            .with_help_message("Choose the actor you want to modify")
            .prompt()?;

        // Load persona details
        let persona = runner.get_persona_details(&selected_id)?;

        // Show edit menu
        loop {
            UI::clear_screen()?;
            UI::show_section_header(&format!("Editing: {}", persona.name), "âœï¸")?;
            UI::show_info(&format!("ID: {}", persona.id))?;

            let edit_options = vec!["Edit Name", "Edit Custom Fields", "Back to Menu"];

            let choice = Select::new("What would you like to edit?", edit_options).prompt()?;

            match choice {
                "Edit Name" => Self::edit_persona_name(&mut runner, &selected_id, &persona)?,
                "Edit Custom Fields" => {
                    Self::edit_persona_fields(&mut runner, &selected_id, &persona)?
                }
                "Back to Menu" => break,
                _ => {}
            }

            // Reload persona after edits
            let _persona = runner.get_persona_details(&selected_id)?;
        }

        UI::pause_for_input()?;
        Ok(())
    }

    /// Edit persona name
    fn edit_persona_name(
        runner: &mut InteractiveRunner,
        persona_id: &str,
        persona: &crate::core::Persona,
    ) -> Result<()> {
        UI::show_section_header("Edit Persona Name", "ðŸ“")?;

        let new_name = Text::new("Name:")
            .with_default(&persona.name)
            .with_help_message("Press Enter to keep current value")
            .prompt()?;

        if new_name == persona.name {
            UI::show_info("No changes made.")?;
            return Ok(());
        }

        let result = runner.update_persona_name(persona_id.to_string(), Some(new_name))?;

        UI::show_success(&result)?;
        UI::pause_for_input()?;
        Ok(())
    }

    /// Edit persona custom fields
    fn edit_persona_fields(
        runner: &mut InteractiveRunner,
        persona_id: &str,
        _persona: &crate::core::Persona,
    ) -> Result<()> {
        UI::show_section_header("Edit Custom Fields", "ðŸŽ¯")?;

        // Get field configuration
        let field_config = runner.get_persona_field_config()?;

        if field_config.is_empty() {
            UI::show_info("No custom fields defined in project configuration.")?;
            UI::pause_for_input()?;
            return Ok(());
        }

        // Get current values
        let current_values = runner.get_persona_field_values(persona_id)?;

        // Prompt for each field
        let mut updated_fields = HashMap::new();

        UI::show_info("Edit fields (smart input based on field type):")?;

        for (field_name, field_def) in &field_config {
            let current_json = current_values.get(field_name);
            let help_msg = field_def
                .description
                .clone()
                .unwrap_or_else(|| format!("{} field", field_def.field_type));

            // Use FieldHelpers to handle different field types automatically
            if let Some(new_value) = FieldHelpers::edit_by_type(
                &field_def.field_type,
                &field_name,
                current_json,
                &help_msg,
            )? {
                updated_fields.insert(field_name.clone(), new_value);
            }
        }

        if updated_fields.is_empty() {
            UI::show_info("No changes made.")?;
            return Ok(());
        }

        let result = runner.update_persona_fields(persona_id.to_string(), updated_fields)?;

        UI::show_success(&result)?;
        UI::pause_for_input()?;
        Ok(())
    }

    /// Interactive actor management menu
    pub fn manage_personas() -> Result<()> {
        UI::clear_screen()?;
        UI::show_section_header("Actor Management", "ðŸ‘¤")?;

        loop {
            let options = vec![
                "Create New Actor",
                "Edit Actor",
                "List All Actors",
                "Show Actor Details",
                "Delete Actor",
                "Back to Main Menu",
            ];

            let choice = Select::new("What would you like to do?", options).prompt()?;

            match choice {
                "Create New Actor" => Self::create_persona()?,
                "Edit Actor" => Self::edit_persona()?,
                "List All Actors" => Self::list_personas()?,
                "Show Actor Details" => Self::show_persona()?,
                "Delete Actor" => Self::delete_persona()?,
                "Back to Main Menu" => break,
                _ => {}
            }
        }

        Ok(())
    }
}
